# Hierarchical Local-Agent Orchestration on CPU

This document has **two purposes**:

1. **Methodology Report** — a high‑level, shareable explanation of *what we are doing and why*.
2. **Operational Spec (`ORCHESTRATION.md`)** — a concrete, drop‑in guide describing agent tiers, directory ownership, routing, and gating.

The system is designed around **measured CPU inference performance on a large‑RAM AMD EPYC system**, with explicit attention to throughput, latency, and architectural correctness.

---

## PART I — METHODOLOGY REPORT (High‑Level Overview)

### 1. Problem Statement

Modern LLM workflows mix **fundamentally different tasks**:

- conversational reasoning and tool use
- long‑form document synthesis
- software engineering across languages and abstraction levels
- personal knowledge and media management

Running all of these through a single monolithic model is inefficient:
- latency is unnecessarily high
- throughput is wasted on tasks that do not need deep reasoning
- quality drifts when small changes affect global context

At the same time, local inference on CPU introduces **hard constraints**:
- token generation cost dominates
- memory bandwidth and KV‑cache growth are limiting factors
- not all acceleration techniques apply to all architectures (dense vs MoE vs SSM)

### 2. Core Insight

**Reasoning, planning, and expansion are separable.**

If we decompose work into:

1. **Planning / architecture / invariants** (low token count, high value)
2. **Expansion / implementation / rewriting** (high token count, lower entropy)
3. **Verification** (tool‑driven, deterministic)

…then each phase can be handled by the *cheapest model capable of doing it correctly*.

This mirrors speculative decoding at the *system level*:
- a strong model sets the trajectory
- many cheap models propose tokens/artifacts in parallel
- correctness is enforced by gates, not by “agreement”

### 3. Hierarchical Agent Design

The system is intentionally **hierarchical, not a swarm**.

- A small number of high‑quality models make irreversible decisions.
- Most tokens are generated by fast, cheap workers.
- Disagreement is resolved by **tests and schemas**, not discussion.

Key design principles:

- **Artifacts over prose**: agents emit IR, code, tests, or diffs
- **Contracts first**: APIs, invariants, and tests constrain expansion
- **Verification gates** replace consensus
- **Explicit routing** prevents over‑thinking

### 4. Performance‑Driven Choices

Based on empirical benchmarks:

- **Dense models** benefit most from speculative decoding
- **MoE models** benefit from expert reduction, *not* speculation
- **SSM‑hybrid models** (Qwen3‑Next) should not use speculative decoding or prompt lookup
- **Very small drafts (≈0.5B)** outperform larger drafts on CPU

This leads to a mixed architecture where **different acceleration strategies coexist** but are applied selectively.

### 5. Outcomes

The resulting system provides:

- low‑latency conversational interaction
- high‑throughput parallel coding and document generation
- deterministic convergence via tool gates
- efficient use of large system RAM without unnecessary CPU contention

Crucially, the system is **model‑agnostic below the planning layer**: new workers can be swapped in without changing the architecture, as long as they respect contracts.

---

## PART II — OPERATIONAL SPEC (`ORCHESTRATION.md`)

### 1. Agent Tiers

#### Tier A — Front Door / Orchestrator
**Purpose:** interactive chat, voice interface, intent classification, task routing

- Owns: task decomposition, tool invocation, final response synthesis
- Emits: `TaskIR` (JSON)
- Must be low‑latency and always resident

#### Tier B — Specialists

**B1: Coding Specialist**
- Primary code generation, refactors, tests
- Dense model + speculative decoding

**B2: Long‑Context Specialist**
- Document ingestion, cross‑source synthesis
- MoE/SSM model with expert reduction only

**B3: Architect / Escalation**
- System design, invariants, acceptance tests
- Emits Architecture IR, *not bulk code*

#### Tier C — Workers (Parallel)

- File‑level implementation
- Test writing
- Documentation rewriting
- Math / edge‑case reasoning
- Vision / UI extraction (when needed)

Workers are **stateless** and cheap; many may run concurrently.

#### Tier D — Draft / Decompressor

- Tiny model used for speculative decoding
- One per active dense‑model stream

---

### 2. Directory Ownership Model

```
repo/
├── architecture/        # Tier B3 only
├── contracts/           # APIs, schemas (Tier B specialists)
├── src/
│   ├── module_a/        # Owned by one worker at a time
│   ├── module_b/
├── tests/
│   ├── unit/
│   ├── integration/
├── tools/               # Scripts, CLIs
├── docs/
└── orchestration/
    ├── task_ir.schema.json
    ├── architecture_ir.schema.json
```

Rules:
- Only Tier B3 may change `architecture/`
- Workers may not invent new public APIs
- Contracts change before implementations

---

### 3. Task IR (Emitted by Front Door)

```json
{
  "task_type": "code | doc | ingest | manage",
  "objective": "string",
  "inputs": ["paths", "urls", "notes"],
  "constraints": ["language", "performance", "security"],
  "definition_of_done": ["tests pass", "doc compiled"],
  "suggested_agents": ["coding", "worker", "vision"],
  "escalation_allowed": true
}
```

---

### 4. Gating Checklist (Non‑Negotiable)

Every artifact must pass, in order:

1. **Schema validation** (IR / JSON / OpenAPI)
2. **Formatting & lint**
3. **Typecheck / build**
4. **Unit tests**
5. **Integration tests** (if applicable)
6. **Security / invariant checks** (if defined)

Failures are routed back to:
- the original worker **once**
- then escalated one tier

No free‑form retries.

---

### 5. Routing Rules (Minimal & Deterministic)

- Short interactive query → Tier A only
- Code generation → Tier B1 + workers
- Large context (>N tokens) → Tier B2 first
- Architectural ambiguity → Tier B3
- Two gate failures → escalate

---

### 6. Memory Residency Policy

**Always Hot (pinned):**
- Front Door model
- Primary coding specialist
- Draft model
- 2–4 worker instances

**Warm (mmap + page cache):**
- Long‑context specialist
- Architect models

Avoid pinning everything: CPU inference bottlenecks shift from RAM capacity to **memory bandwidth and thread contention**.

---

### 7. System Philosophy (Non‑Technical Summary)

> *One model thinks.
> Many models work.
> Tools decide who is right.*

This system optimizes for **throughput, correctness, and composability**, not anthropomorphic agent behavior.

---

---

## APPENDIX A — `ORCHESTRATION.md` (Strict Operational Spec)

> This appendix is intended to be copied directly into a repo as `ORCHESTRATION.md`.

### A1. Purpose

This repository uses a **hierarchical local-agent workflow**. The goal is to:
- minimize latency for interactive use
- maximize throughput for bulk generation
- preserve correctness via **verification gates**

### A2. Non-Negotiables

1. **Contracts first.** Public APIs and schemas must be declared before implementation.
2. **Artifacts over prose.** Agents emit diffs, IR, tests, or structured outputs.
3. **Gates decide correctness.** No “debate-driven” convergence.
4. **Escalation is controlled.** Two gate failures triggers escalation.

### A3. Tier Definitions

**Tier A — Front Door**
- interactive chat (voice/text)
- tool routing
- emits `TaskIR.json`
- merges results into final output

**Tier B — Specialists**
- B1 Coding specialist (dense+spec)
- B2 Ingestion/long-context specialist (Next; no spec/lookup)
- B3 Architect/escalation (IR + invariants + acceptance tests)

**Tier C — Workers**
- file-level implementers
- test writers
- doc rewriters
- math/edge-case
- vision/UI extraction

**Tier D — Draft**
- speculative decoding draft model
- one per active dense target stream

### A4. Repository Layout & Ownership

```
architecture/   # B3 only (system design, invariants, ADRs)
contracts/      # B specialists (OpenAPI/JSONSchema/protos)
src/            # C workers implement per-module
tests/          # B1 + C workers
tools/          # automation scripts
orchestration/  # schemas, routing, prompts
```

**Ownership rules**
- Workers may not create new public APIs without updating `contracts/`.
- If a change touches multiple modules, a specialist must own the merge.
- `architecture/` is write-protected except for B3.

### A5. Verification Gates

Artifacts must pass, in order:
1. schema validation (for IR/contracts)
2. formatting + lint
3. build/typecheck
4. unit tests
5. integration tests (if applicable)
6. security checks/invariants (if defined)

**Failure routing**
- First failure → return to producing agent.
- Second failure → escalate one tier.
- Third failure → escalate to B3 and require an IR/contract fix.

### A6. TODOs (Project-Specific)

- [ ] Define exact `TaskIR` schema in `orchestration/task_ir.schema.json`
- [ ] Define `ArchitectureIR` schema in `orchestration/architecture_ir.schema.json`
- [ ] Add `make gates` (or `just gates`) to run all verification gates
- [ ] Add CI that mirrors local gates
- [ ] Add a “module ownership” registry (simple YAML)

---

## APPENDIX B — Front Door Routing Prompt (Forces `TaskIR` JSON)

> Use this as the system/developer prompt for the Front Door model.

### B1. Prompt

You are the **Front Door Orchestrator** for a local hierarchical agent system.

**Your job** is to:
1) understand the user’s request,
2) choose the best workflow and agents,
3) output a single JSON object called `TaskIR` that strictly follows the schema.

**Do not** write explanations, prose, or code unless the user explicitly requests a direct answer.

**If the request is ambiguous**, choose the safest default and encode open questions as `assumptions[]` rather than asking follow-ups.

**If tool use is required**, include it in `plan.steps[]`.

#### Output requirements
- Output **only** JSON.
- Must include all required fields.
- Must include an explicit `definition_of_done`.

### B2. Example `TaskIR` schema (informal)

```json
{
  "task_type": "chat|doc|code|ingest|manage",
  "priority": "interactive|batch",
  "objective": "...",
  "inputs": [{"type":"path|url|text", "value":"..."}],
  "constraints": ["..."],
  "assumptions": ["..."],
  "agents": [
    {"tier":"A|B|C|D", "role":"frontdoor|coder|ingest|architect|worker|vision|math|draft", "model_hint":"..."}
  ],
  "plan": {
    "steps": [
      {"id":"S1", "actor":"agent-role", "action":"...", "outputs":["..."]}
    ]
  },
  "gates": ["schema", "format", "lint", "build", "unit", "integration"],
  "definition_of_done": ["..."],
  "escalation": {"max_level": "B3", "on_second_failure": true}
}
```

---

## APPENDIX C — Dispatcher Pseudocode Loop (Python)

> High-level pseudocode showing how routing, parallelism, and gates interact.

```python
from dataclasses import dataclass
from typing import Any, Dict, List

@dataclass
class TaskIR:
    task_type: str
    priority: str
    objective: str
    inputs: List[Dict[str, str]]
    constraints: List[str]
    assumptions: List[str]
    agents: List[Dict[str, str]]
    plan: Dict[str, Any]
    gates: List[str]
    definition_of_done: List[str]
    escalation: Dict[str, Any]

class GateResult:
    def __init__(self, ok: bool, report: Dict[str, Any]):
        self.ok = ok
        self.report = report

class Orchestrator:
    def __init__(self, model_registry, gate_runner, workspace):
        self.model_registry = model_registry
        self.gate_runner = gate_runner
        self.workspace = workspace

    def frontdoor(self, user_msg: str) -> TaskIR:
        # Call Tier-A model; must return JSON TaskIR
        return self.model_registry.call_frontdoor(user_msg)

    def run(self, user_msg: str) -> Dict[str, Any]:
        task = self.frontdoor(user_msg)
        artifacts = []

        # Execute plan steps; allow parallel workers where safe
        for step in task.plan["steps"]:
            actor = step["actor"]
            action = step["action"]
            outputs = self.model_registry.call_actor(actor, action, task)
            artifacts.extend(outputs)

            # Optional: run local micro-gates per step
            if step.get("run_gates", False):
                gr = self.gate_runner.run(task.gates)
                if not gr.ok:
                    return self._handle_failure(task, step, gr)

        # Run full gates at end
        gr = self.gate_runner.run(task.gates)
        if not gr.ok:
            return self._handle_failure(task, None, gr)

        # Final synthesis (Tier-A)
        final = self.model_registry.call_frontdoor_synthesis(task, artifacts)
        return {"task": task, "artifacts": artifacts, "result": final}

    def _handle_failure(self, task: TaskIR, step, gr: GateResult) -> Dict[str, Any]:
        # Route first failure back to producing agent; second failure escalates.
        failures = self.workspace.increment_failure_counter(gr.report)
        if failures == 1:
            fixer = self.workspace.infer_owner_agent(gr.report)  # usually same worker
        elif failures == 2:
            fixer = self.workspace.escalate_owner_agent(gr.report)  # next tier up
        else:
            fixer = "B3-architect"

        fix_outputs = self.model_registry.call_actor(
            fixer,
            action=f"Fix gates failure: {gr.report}",
            context=task,
        )

        # Re-run gates after fix
        gr2 = self.gate_runner.run(task.gates)
        if not gr2.ok and fixer != "B3-architect":
            # escalate hard
            return self._handle_failure(task, step, gr2)

        final = self.model_registry.call_frontdoor_synthesis(task, fix_outputs)
        return {"task": task, "fixes": fix_outputs, "result": final}
```

---

## APPENDIX D — Voice-First Front Door Prompt Variant

> Use this when the user is speaking live and latency matters.

### D1. Rules

- Keep interactive turns short.
- Prefer **confirming intent implicitly** via TaskIR assumptions.
- Defer heavy work to background agents.
- Always provide a brief spoken acknowledgment + what will happen next.

### D2. Voice-First Prompt

You are a **voice-first Front Door Orchestrator**.

Output two things:
1) a short, spoken response (1–2 sentences) in `"voice_reply"`
2) a strict `TaskIR` JSON in `"task_ir"`

Do not output anything else.

Example output:

```json
{
  "voice_reply": "Okay — I’ll draft the architecture plan and then spawn parallel workers to generate the modules. I’ll report back with a test-passing patch.",
  "task_ir": { /* strict TaskIR as in Appendix B */ }
}
```

---

---

## APPENDIX E — `orchestration/task_ir.schema.json` (JSON Schema)

> Save as `orchestration/task_ir.schema.json`.

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://local.example/schemas/task_ir.schema.json",
  "title": "TaskIR",
  "type": "object",
  "additionalProperties": false,
  "required": [
    "task_type",
    "priority",
    "objective",
    "inputs",
    "constraints",
    "assumptions",
    "agents",
    "plan",
    "gates",
    "definition_of_done",
    "escalation"
  ],
  "properties": {
    "task_type": {
      "type": "string",
      "enum": ["chat", "doc", "code", "ingest", "manage"]
    },
    "priority": {
      "type": "string",
      "enum": ["interactive", "batch"]
    },
    "objective": { "type": "string", "minLength": 1 },
    "inputs": {
      "type": "array",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["type", "value"],
        "properties": {
          "type": { "type": "string", "enum": ["path", "url", "text", "image", "audio"] },
          "value": { "type": "string", "minLength": 1 },
          "label": { "type": "string" },
          "content_type": { "type": "string" }
        }
      },
      "default": []
    },
    "constraints": {
      "type": "array",
      "items": { "type": "string" },
      "default": []
    },
    "assumptions": {
      "type": "array",
      "items": { "type": "string" },
      "default": []
    },
    "agents": {
      "type": "array",
      "minItems": 1,
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["tier", "role"],
        "properties": {
          "tier": { "type": "string", "enum": ["A", "B", "C", "D"] },
          "role": {
            "type": "string",
            "enum": [
              "frontdoor",
              "coder",
              "ingest",
              "architect",
              "worker",
              "docwriter",
              "math",
              "vision",
              "toolrunner",
              "draft"
            ]
          },
          "model_hint": { "type": "string" },
          "max_concurrency": { "type": "integer", "minimum": 1 },
          "notes": { "type": "string" }
        }
      }
    },
    "plan": {
      "type": "object",
      "additionalProperties": false,
      "required": ["steps"],
      "properties": {
        "steps": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": ["id", "actor", "action", "outputs"],
            "properties": {
              "id": { "type": "string", "pattern": "^S[0-9]+$" },
              "actor": { "type": "string", "minLength": 1 },
              "action": { "type": "string", "minLength": 1 },
              "inputs": {
                "type": "array",
                "items": { "type": "string" },
                "default": []
              },
              "outputs": {
                "type": "array",
                "minItems": 1,
                "items": { "type": "string" }
              },
              "run_gates": { "type": "boolean", "default": false },
              "parallel_group": { "type": "string" },
              "timeout_seconds": { "type": "integer", "minimum": 1 }
            }
          }
        }
      }
    },
    "gates": {
      "type": "array",
      "minItems": 1,
      "items": {
        "type": "string",
        "enum": ["schema", "format", "lint", "build", "typecheck", "unit", "integration", "security", "bench"]
      }
    },
    "definition_of_done": {
      "type": "array",
      "minItems": 1,
      "items": { "type": "string" }
    },
    "escalation": {
      "type": "object",
      "additionalProperties": false,
      "required": ["max_level", "on_second_failure"],
      "properties": {
        "max_level": { "type": "string", "enum": ["B1", "B2", "B3"] },
        "on_second_failure": { "type": "boolean" },
        "notes": { "type": "string" }
      }
    }
  }
}
```

---

## APPENDIX F — `orchestration/architecture_ir.schema.json` (JSON Schema)

> Save as `orchestration/architecture_ir.schema.json`. This is what Tier-B3 should emit.

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "$id": "https://local.example/schemas/architecture_ir.schema.json",
  "title": "ArchitectureIR",
  "type": "object",
  "additionalProperties": false,
  "required": [
    "name",
    "version",
    "goals",
    "non_goals",
    "global_invariants",
    "repo_layout",
    "modules",
    "contracts",
    "cross_cutting",
    "acceptance"
  ],
  "properties": {
    "name": { "type": "string", "minLength": 1 },
    "version": { "type": "string", "minLength": 1 },
    "context": {
      "type": "object",
      "additionalProperties": true,
      "properties": {
        "domain": { "type": "string" },
        "language_stack": { "type": "array", "items": { "type": "string" } },
        "constraints": { "type": "array", "items": { "type": "string" } }
      }
    },
    "goals": { "type": "array", "minItems": 1, "items": { "type": "string" } },
    "non_goals": { "type": "array", "items": { "type": "string" }, "default": [] },
    "global_invariants": { "type": "array", "items": { "type": "string" }, "default": [] },

    "repo_layout": {
      "type": "object",
      "additionalProperties": false,
      "required": ["folders"],
      "properties": {
        "folders": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": ["path", "owner_role", "purpose"],
            "properties": {
              "path": { "type": "string", "minLength": 1 },
              "owner_role": { "type": "string", "minLength": 1 },
              "purpose": { "type": "string", "minLength": 1 },
              "rules": { "type": "array", "items": { "type": "string" }, "default": [] }
            }
          }
        }
      }
    },

    "modules": {
      "type": "array",
      "minItems": 1,
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["id", "name", "responsibilities", "public_api", "dependencies", "files"],
        "properties": {
          "id": { "type": "string", "pattern": "^[a-z0-9_\-]+$" },
          "name": { "type": "string", "minLength": 1 },
          "responsibilities": { "type": "array", "minItems": 1, "items": { "type": "string" } },
          "public_api": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": false,
              "required": ["symbol", "signature", "description"],
              "properties": {
                "symbol": { "type": "string", "minLength": 1 },
                "signature": { "type": "string", "minLength": 1 },
                "description": { "type": "string", "minLength": 1 },
                "invariants": { "type": "array", "items": { "type": "string" }, "default": [] }
              }
            },
            "default": []
          },
          "dependencies": {
            "type": "object",
            "additionalProperties": false,
            "required": ["allows", "forbids"],
            "properties": {
              "allows": { "type": "array", "items": { "type": "string" }, "default": [] },
              "forbids": { "type": "array", "items": { "type": "string" }, "default": [] }
            }
          },
          "files": {
            "type": "array",
            "minItems": 1,
            "items": {
              "type": "object",
              "additionalProperties": false,
              "required": ["path", "purpose"],
              "properties": {
                "path": { "type": "string", "minLength": 1 },
                "purpose": { "type": "string", "minLength": 1 },
                "owner_role": { "type": "string" }
              }
            }
          }
        }
      }
    },

    "contracts": {
      "type": "array",
      "items": {
        "type": "object",
        "additionalProperties": false,
        "required": ["id", "type", "path", "scope"],
        "properties": {
          "id": { "type": "string", "minLength": 1 },
          "type": { "type": "string", "enum": ["openapi", "jsonschema", "proto", "python-types", "ts-types"] },
          "path": { "type": "string", "minLength": 1 },
          "scope": { "type": "string", "enum": ["public", "internal"] },
          "notes": { "type": "string" }
        }
      },
      "default": []
    },

    "cross_cutting": {
      "type": "object",
      "additionalProperties": false,
      "required": ["logging", "errors", "config", "security"],
      "properties": {
        "logging": { "type": "array", "items": { "type": "string" }, "default": [] },
        "errors": {
          "type": "object",
          "additionalProperties": false,
          "required": ["error_codes", "strategy"],
          "properties": {
            "error_codes": { "type": "array", "items": { "type": "string" }, "default": [] },
            "strategy": { "type": "string", "minLength": 1 }
          }
        },
        "config": { "type": "array", "items": { "type": "string" }, "default": [] },
        "security": { "type": "array", "items": { "type": "string" }, "default": [] }
      }
    },

    "acceptance": {
      "type": "object",
      "additionalProperties": false,
      "required": ["tests", "benchmarks", "definition_of_done"],
      "properties": {
        "tests": {
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "required": ["id", "type", "description"],
            "properties": {
              "id": { "type": "string", "minLength": 1 },
              "type": { "type": "string", "enum": ["unit", "integration", "e2e", "property"] },
              "description": { "type": "string", "minLength": 1 },
              "files": { "type": "array", "items": { "type": "string" }, "default": [] }
            }
          },
          "default": []
        },
        "benchmarks": { "type": "array", "items": { "type": "string" }, "default": [] },
        "definition_of_done": { "type": "array", "minItems": 1, "items": { "type": "string" } }
      }
    }
  }
}
```

---

## APPENDIX G — `orchestration/model_registry.yaml` (Deterministic Model Mapping)

> This mapping is tuned to your measured winners: dense+spec for 32B, expert reduction for MoE, and Next-80B for ingestion.

```yaml
# Model Registry (deterministic)
# The dispatcher should choose models by role + tier, not by improvisation.

runtime_defaults:
  quantization_default: Q4_K_M
  draft_quantization_default: Q8_0
  context_default: 8192
  temperature_default: 0.2

roles:
  # Tier A — Front Door
  frontdoor:
    tier: A
    model: Qwen3-Coder-30B-A3B-Instruct
    quant: Q4_K_M
    acceleration:
      type: moe_expert_reduction
      experts: 4
    notes: "Primary interactive orchestrator (fast, agentic)."

  # Tier B — Specialists
  coder_primary:
    tier: B
    model: Qwen2.5-Coder-32B-Instruct
    quant: Q4_K_M
    acceleration:
      type: speculative_decoding
      draft:
        model: Qwen2.5-Coder-0.5B-Instruct
        quant: Q8_0
      k: 24
    notes: "Primary codegen/refactor lane."

  ingest_long_context:
    tier: B
    model: Qwen3-Next-80B-A3B-Instruct
    quant: Q4_K_M
    acceleration:
      type: moe_expert_reduction
      experts: 2
    constraints:
      forbid:
        - speculative_decoding
        - prompt_lookup
    notes: "Huge-context ingestion and synthesis."

  architect_general:
    tier: B
    model: Qwen3-235B-A22B-Instruct
    quant: Q4_K_M
    acceleration:
      type: moe_expert_reduction
      experts: 4
    notes: "System architecture, invariants, acceptance tests (emit IR)."

  architect_coding:
    tier: B
    model: Qwen3-Coder-480B-A35B-Instruct
    quant: Q4_K_M
    acceleration:
      type: moe_expert_reduction
      experts: 4
    constraints:
      forbid:
        - speculative_decoding
    notes: "Hardest coding/architecture escalation; IR-first."

  # Tier C — Workers
  worker_general:
    tier: C
    model: Meta-Llama-3-8B-Instruct
    quant: Q4_K_M
    acceleration:
      type: prompt_lookup
    notes: "Boilerplate, rewrites, doc polish, small diffs."

  worker_math:
    tier: C
    model: Qwen2.5-Math-7B-Instruct
    quant: Q4_K_M
    acceleration:
      type: speculative_decoding
      draft:
        model: Qwen2.5-Coder-0.5B-Instruct
        quant: Q8_0
      k: 8
    notes: "Edge cases, invariants, property-test generation."

  worker_vision:
    tier: C
    model: Qwen2.5-VL-7B-Instruct
    quant: Q4_K_M
    acceleration:
      type: speculative_decoding
      draft:
        model: Qwen2.5-Coder-0.5B-Instruct
        quant: Q8_0
      k: 8
    notes: "Screenshots/UI extraction; outputs component trees + structured notes."

  toolrunner:
    tier: C
    model: Meta-Llama-3-8B-Instruct
    quant: Q4_K_M
    acceleration:
      type: none
    notes: "Summarize tool outputs, triage logs, propose next commands."

  # Tier D — Draft
  draft_default:
    tier: D
    model: Qwen2.5-Coder-0.5B-Instruct
    quant: Q8_0
    notes: "Default draft for dense speculative decoding."

process_layout:
  # Suggested starting point; tune based on bandwidth/latency.
  hot_resident:
    - frontdoor
    - coder_primary
    - draft_default
    - worker_general
    - worker_general
    - worker_math
  warm_mmap:
    - ingest_long_context
    - architect_general
    - architect_coding

routing_hints:
  # Simple deterministic routing the dispatcher can apply.
  - if: "task_type == 'code'"
    use: ["coder_primary"]
  - if: "task_type == 'ingest'"
    use: ["ingest_long_context"]
  - if: "task_type == 'doc' and priority == 'interactive'"
    use: ["frontdoor", "worker_general"]
  - if: "task_type == 'manage'"
    use: ["frontdoor", "toolrunner", "worker_general"]
  - if: "needs_math_reasoning == true"
    use: ["worker_math"]
  - if: "has_images == true"
    use: ["worker_vision"]
```

---

---

## APPENDIX H — Tiny Python IR Validator

> Add these files to your repo. This validator:
> - loads the JSON Schemas from `orchestration/`
> - validates `TaskIR` and `ArchitectureIR`
> - prints human-friendly errors
>
> Dependencies: `pip install jsonschema` (or add to Poetry).

### H1. `orchestration/validate_ir.py`

```python
#!/usr/bin/env python3
"""Validate TaskIR / ArchitectureIR JSON files against local JSON Schemas.

Usage:
  python orchestration/validate_ir.py task path/to/task_ir.json
  python orchestration/validate_ir.py arch path/to/architecture_ir.json

Exit codes:
  0 = valid
  2 = invalid
  3 = missing file / schema
"""

from __future__ import annotations

import json
import sys
from pathlib import Path
from typing import Any, Dict

try:
    from jsonschema import Draft202012Validator
except Exception as e:  # pragma: no cover
    print("ERROR: missing dependency 'jsonschema'. Install with: pip install jsonschema")
    raise


ROOT = Path(__file__).resolve().parents[1]
SCHEMA_TASK = ROOT / "orchestration" / "task_ir.schema.json"
SCHEMA_ARCH = ROOT / "orchestration" / "architecture_ir.schema.json"


def _load_json(path: Path) -> Dict[str, Any]:
    if not path.exists():
        raise FileNotFoundError(str(path))
    with path.open("r", encoding="utf-8") as f:
        return json.load(f)


def _format_error(err) -> str:
    # err.path is a deque; convert to a nice JSON pointer-ish path
    loc = "$." + ".".join(str(p) for p in err.path) if err.path else "$"
    msg = err.message
    return f"- {loc}: {msg}"


def validate(instance_path: Path, schema_path: Path) -> int:
    try:
        schema = _load_json(schema_path)
    except FileNotFoundError:
        print(f"ERROR: schema not found: {schema_path}")
        return 3

    try:
        instance = _load_json(instance_path)
    except FileNotFoundError:
        print(f"ERROR: JSON file not found: {instance_path}")
        return 3

    validator = Draft202012Validator(schema)
    errors = sorted(validator.iter_errors(instance), key=lambda e: list(e.path))

    if not errors:
        print(f"OK: {instance_path} is valid.")
        return 0

    print(f"INVALID: {instance_path}")
    for e in errors[:200]:
        print(_format_error(e))

    if len(errors) > 200:
        print(f"... and {len(errors) - 200} more errors")

    return 2


def main(argv: list[str]) -> int:
    if len(argv) != 3 or argv[1] not in {"task", "arch"}:
        print("Usage: validate_ir.py (task|arch) path/to/file.json")
        return 2

    kind = argv[1]
    instance_path = Path(argv[2]).expanduser().resolve()

    schema_path = SCHEMA_TASK if kind == "task" else SCHEMA_ARCH
    return validate(instance_path, schema_path)


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))
```

### H2. Optional: `orchestration/validate_taskir_from_stdin.py`

> Useful if your Front Door prints JSON to stdout.

```python
#!/usr/bin/env python3
"""Read TaskIR JSON from stdin and validate it."""

from __future__ import annotations

import json
import sys
from pathlib import Path

from jsonschema import Draft202012Validator

ROOT = Path(__file__).resolve().parents[1]
SCHEMA_TASK = ROOT / "orchestration" / "task_ir.schema.json"


def main() -> int:
    schema = json.loads(SCHEMA_TASK.read_text(encoding="utf-8"))
    instance = json.loads(sys.stdin.read())

    v = Draft202012Validator(schema)
    errors = sorted(v.iter_errors(instance), key=lambda e: list(e.path))

    if not errors:
        print("OK: stdin TaskIR is valid")
        return 0

    print("INVALID: stdin TaskIR")
    for e in errors[:200]:
        loc = "$." + ".".join(str(p) for p in e.path) if e.path else "$"
        print(f"- {loc}: {e.message}")
    return 2


if __name__ == "__main__":
    raise SystemExit(main())
```

---

## APPENDIX I — `make gates` and `just gates` Skeleton

Below are two equivalent options. Choose one.

### Option 1: Makefile (`make gates`)

Save as `Makefile` at repo root:

```makefile
SHELL := /usr/bin/env bash

.PHONY: gates schema format lint typecheck unit integration security bench

# ---- CONFIG: adjust to your stack ----
PY ?= python

# Python tooling (replace with poetry/uv as you prefer)
FORMATTER ?= ruff
LINTER ?= ruff
TYPECHECKER ?= mypy
TEST ?= pytest

# Optional: for C++ repos, set these and wire them below
CMAKE_BUILD_DIR ?= build

# Default gate chain

gates: schema format lint typecheck unit integration
	@echo "✅ gates: all passed"

schema:
	@echo "==> schema"
	@# Validate any IR files you produce. Example paths:
	@# $(PY) orchestration/validate_ir.py task orchestration/last_task_ir.json
	@# $(PY) orchestration/validate_ir.py arch architecture/architecture_ir.json
	@true

format:
	@echo "==> format"
	@# Python
	@command -v $(FORMATTER) >/dev/null 2>&1 && $(FORMATTER) format . || true

lint:
	@echo "==> lint"
	@# Python
	@command -v $(LINTER) >/dev/null 2>&1 && $(LINTER) check . || true

typecheck:
	@echo "==> typecheck"
	@# Python
	@command -v $(TYPECHECKER) >/dev/null 2>&1 && $(TYPECHECKER) . || true

unit:
	@echo "==> unit"
	@# Python
	@command -v $(TEST) >/dev/null 2>&1 && $(TEST) -q tests/unit || true

integration:
	@echo "==> integration"
	@# Python
	@command -v $(TEST) >/dev/null 2>&1 && $(TEST) -q tests/integration || true

security:
	@echo "==> security"
	@# Example: bandit, semgrep, trivy, etc.
	@true

bench:
	@echo "==> bench"
	@# Example: pytest-benchmark, custom perf harness
	@true
```

### Option 2: Justfile (`just gates`)

Save as `Justfile` at repo root:

```makefile
# Requires: just (https://github.com/casey/just)

set shell := ["bash", "-cu"]

# ---- CONFIG: adjust to your stack ----
py := "python"

formatter := "ruff"
linter := "ruff"
typechecker := "mypy"
test := "pytest"

# Gate chain

gates: schema format lint typecheck unit integration
  echo "✅ gates: all passed"

schema:
  echo "==> schema"
  # {{py}} orchestration/validate_ir.py task orchestration/last_task_ir.json
  # {{py}} orchestration/validate_ir.py arch architecture/architecture_ir.json
  true

format:
  echo "==> format"
  command -v {{formatter}} >/dev/null 2>&1 && {{formatter}} format . || true

lint:
  echo "==> lint"
  command -v {{linter}} >/dev/null 2>&1 && {{linter}} check . || true

typecheck:
  echo "==> typecheck"
  command -v {{typechecker}} >/dev/null 2>&1 && {{typechecker}} . || true

unit:
  echo "==> unit"
  command -v {{test}} >/dev/null 2>&1 && {{test}} -q tests/unit || true

integration:
  echo "==> integration"
  command -v {{test}} >/dev/null 2>&1 && {{test}} -q tests/integration || true

security:
  echo "==> security"
  true

bench:
  echo "==> bench"
  true
```

### I3. How to use gates with agents

- Workers must produce code + tests, then you (or the dispatcher) run `make gates` / `just gates`.
- On failure, feed the *gate report* back to the producing agent once.
- Second failure escalates one tier.

---

**End of document.**

