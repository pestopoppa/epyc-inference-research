{
  "suite": "coder",
  "prompts_compared": 10,
  "avg_speedup": 0,
  "avg_orchestrator_latency_ms": 55673.51342092734,
  "avg_turns": 1.0,
  "quality_pass_rate": 70.0,
  "quality_errors": 3,
  "avg_tps": 32.80975508241606,
  "routing_distribution": {
    "frontdoor": 10
  },
  "results": [
    {
      "prompt_id": "t3_q1_concurrent_correctness",
      "suite": "coder",
      "tier": 3,
      "direct_answer": "",
      "direct_latency_ms": 0,
      "direct_score": null,
      "orchestrator_answer": "[ERROR: Inference failed: Request timed out after 120s]",
      "orchestrator_latency_ms": 120172.0324861817,
      "orchestrator_turns": 1,
      "orchestrator_routed_to": "frontdoor",
      "quality_match": false,
      "speedup": 0.0,
      "tokens_generated": 0,
      "server_elapsed_s": 120.1466052220203,
      "avg_tps": 0.0
    },
    {
      "prompt_id": "t3_q2_distributed_consistency",
      "suite": "coder",
      "tier": 3,
      "direct_answer": "",
      "direct_latency_ms": 0,
      "direct_score": null,
      "orchestrator_answer": "[ERROR: Inference failed: Request timed out after 120s]",
      "orchestrator_latency_ms": 120204.50372295454,
      "orchestrator_turns": 1,
      "orchestrator_routed_to": "frontdoor",
      "quality_match": false,
      "speedup": 0.0,
      "tokens_generated": 0,
      "server_elapsed_s": 120.17592448112555,
      "avg_tps": 0.0
    },
    {
      "prompt_id": "t3_q3_algorithmic_hardness",
      "suite": "coder",
      "tier": 3,
      "direct_answer": "",
      "direct_latency_ms": 0,
      "direct_score": null,
      "orchestrator_answer": "1. **Omega(n) Lower Bound for Comparison-Based Algorithms**\n\nTo prove that any comparison-based algorithm requires Omega(n) comparisons in the worst case to find the k-th smallest element, we use an adversary argument.\n\n**Adversary Argument:**\n- Consider a game between an algorithm and an adversary.\n- The adversary maintains a set of possible arrays consistent with all previous queries.\n- For each query (comparison), the adversary responds in a way that keeps as many possibilities open as possib",
      "orchestrator_latency_ms": 28466.813131934032,
      "orchestrator_turns": 1,
      "orchestrator_routed_to": "frontdoor",
      "quality_match": true,
      "speedup": 0.0,
      "tokens_generated": 818,
      "server_elapsed_s": 28.44912731507793,
      "avg_tps": 28.753078818219603
    },
    {
      "prompt_id": "t2_q1_design",
      "suite": "coder",
      "tier": 2,
      "direct_answer": "",
      "direct_latency_ms": 0,
      "direct_score": null,
      "orchestrator_answer": "class LRUCache:\n    def __init__(self, capacity: int):\n        pass\n    \n    def get(self, key: int) -> int:\n        pass\n    \n    def put(self, key: int, value: int) -> None:\n        pass\n\n# Explanation of Data Structure Choices:\n\nThe LRU cache requires a data structure that supports O(1) access to elements and the ability to quickly move recently used items to the front. The combination of a hash map (dictionary in Python) and a doubly linked list is ideal for this.\n\nHash Map: Provides O(1) av",
      "orchestrator_latency_ms": 46371.86649115756,
      "orchestrator_turns": 1,
      "orchestrator_routed_to": "frontdoor",
      "quality_match": true,
      "speedup": 0.0,
      "tokens_generated": 1294,
      "server_elapsed_s": 46.3579706158489,
      "avg_tps": 27.913214983522302
    },
    {
      "prompt_id": "t2_q2_debug_complex",
      "suite": "coder",
      "tier": 2,
      "direct_answer": "",
      "direct_latency_ms": 0,
      "direct_score": null,
      "orchestrator_answer": "The explanation should be a narrative that is easy to follow and understand.\n\nExplanation:\nThe race condition in this code occurs because multiple coroutines are accessing and modifying the global variable `counter` without any synchronization mechanism. When these coroutines run concurrently, they can read the same initial value of `counter`, increment it, and write back the new value, causing some increments to be lost.\n\nTo fix this issue, we need to use a lock to ensure that only one coroutin",
      "orchestrator_latency_ms": 24698.492328170687,
      "orchestrator_turns": 1,
      "orchestrator_routed_to": "frontdoor",
      "quality_match": true,
      "speedup": 0.0,
      "tokens_generated": 728,
      "server_elapsed_s": 24.677553063025698,
      "avg_tps": 29.50049375400838
    },
    {
      "prompt_id": "t2_q3_optimize",
      "suite": "coder",
      "tier": 2,
      "direct_answer": "",
      "direct_latency_ms": 0,
      "direct_score": null,
      "orchestrator_answer": "def count_pairs(nums, target):\n    from collections import defaultdict\n    \n    # Dictionary to store frequency of numbers we've seen\n    freq = defaultdict(int)\n    count = 0\n    \n    for num in nums:\n        complement = target - num\n        \n        # If complement exists in our frequency map,\n        # it means we found pairs that sum up to target\n        if complement in freq:\n            count += freq[complement]\n        \n        # Add current number to frequency map\n        freq[num] += 1",
      "orchestrator_latency_ms": 26075.027987128124,
      "orchestrator_turns": 1,
      "orchestrator_routed_to": "frontdoor",
      "quality_match": true,
      "speedup": 0.0,
      "tokens_generated": 787,
      "server_elapsed_s": 26.06248977012001,
      "avg_tps": 30.196654538442285
    },
    {
      "prompt_id": "t2_q4_system",
      "suite": "coder",
      "tier": 2,
      "direct_answer": "",
      "direct_latency_ms": 0,
      "direct_score": null,
      "orchestrator_answer": "```python\nimport time\nfrom collections import deque\n\nclass RateLimiter:\n    def __init__(self, max_requests: int, window_seconds: int):\n        \"\"\"\n        Initialize the rate limiter.\n        \n        Args:\n            max_requests (int): Maximum number of allowed requests\n            window_seconds (int): Time window in seconds\n        \"\"\"\n        self.max_requests = max_requests\n        self.window_seconds = window_seconds\n        self.requests = deque()\n    \n    def is_allowed(self) -> bool:",
      "orchestrator_latency_ms": 22192.68386391923,
      "orchestrator_turns": 1,
      "orchestrator_routed_to": "frontdoor",
      "quality_match": true,
      "speedup": 0.0,
      "tokens_generated": 702,
      "server_elapsed_s": 22.17775194416754,
      "avg_tps": 31.653343484374975
    },
    {
      "prompt_id": "t1_q1_algorithm",
      "suite": "coder",
      "tier": 1,
      "direct_answer": "",
      "direct_latency_ms": 0,
      "direct_score": null,
      "orchestrator_answer": "[ERROR: Inference failed: Request timed out after 120s]",
      "orchestrator_latency_ms": 120147.14127988555,
      "orchestrator_turns": 1,
      "orchestrator_routed_to": "frontdoor",
      "quality_match": false,
      "speedup": 0.0,
      "tokens_generated": 0,
      "server_elapsed_s": 120.14478414598852,
      "avg_tps": 0.0
    },
    {
      "prompt_id": "t1_q2_refactor",
      "suite": "coder",
      "tier": 1,
      "direct_answer": "",
      "direct_latency_ms": 0,
      "direct_score": null,
      "orchestrator_answer": "For example, if a function is O(n) or O(log n), clearly state that and explain what it means in plain English.\n\n---\n\n### Version 1: Optimize for Speed\n\n```python\ndef find_duplicates(items):\n    seen = set()\n    duplicates = set()\n    \n    for item in items:\n        if item in seen:\n            duplicates.add(item)\n        else:\n            seen.add(item)\n    \n    return list(duplicates)\n```\n\n**Explanation:**  \nThis version improves performance by using a `set` to track which elements we've alrea",
      "orchestrator_latency_ms": 37439.763579983264,
      "orchestrator_turns": 1,
      "orchestrator_routed_to": "frontdoor",
      "quality_match": true,
      "speedup": 0.0,
      "tokens_generated": 1381,
      "server_elapsed_s": 37.421500412980095,
      "avg_tps": 36.9039184629001
    },
    {
      "prompt_id": "t1_q3_test",
      "suite": "coder",
      "tier": 1,
      "direct_answer": "",
      "direct_latency_ms": 0,
      "direct_score": null,
      "orchestrator_answer": "Here are the test cases for the `divide` function:\n\n1. **Normal Cases**:\n   - Dividing two positive integers: `divide(6, 2)` should return `3.0`.\n   - Dividing a positive integer by a negative integer: `divide(10, -2)` should return `-5.0`.\n   - Dividing a negative integer by a positive integer: `divide(-8, 4)` should return `-2.0`.\n   - Dividing two negative integers: `divide(-6, -3)` should return `2.0`.\n   - Dividing decimals: `divide(7.5, 1.5)` should return `5.0`.\n\n2. **Edge Cases**:\n   - D",
      "orchestrator_latency_ms": 10966.809337958694,
      "orchestrator_turns": 1,
      "orchestrator_routed_to": "frontdoor",
      "quality_match": true,
      "speedup": 0.0,
      "tokens_generated": 490,
      "server_elapsed_s": 10.950312467990443,
      "avg_tps": 44.74758153544479
    }
  ],
  "timestamp": "2026-01-29T15:24:10.189789"
}